
VocÃª disse:
ğŸ§  VestibulandoBot 2.0 â€“ Backend API

Backend completo em Flask + SQLAlchemy, containerizado com Docker,
e preparado para integraÃ§Ã£o com o front-end Vue/Angular.
Inclui mÃ³dulos de MatÃ©rias, QuestÃµes, Simulados e Resultados.

ğŸ³ 1) PrÃ©-requisitos

Docker Desktop instalado e em execuÃ§Ã£o

Terminal (PowerShell / macOS Terminal / Shell Linux)

Acesso ao repositÃ³rio Git do projeto

Verifique se o Docker estÃ¡ funcionando:

docker --version
docker compose version


âš ï¸ Se docker compose nÃ£o existir, use docker-compose (com hÃ­fen).

ğŸ“‚ 2) Clonar o repositÃ³rio
git clone <URL_DO_SEU_REPO>.git
cd <PASTA_DO_REPO>


Arquivos esperados na raiz:

Dockerfile
docker-compose.yml
requirements.txt
wsgi.py
app/         # cÃ³digo-fonte
data/        # CSVs para importaÃ§Ã£o

âš™ï¸ 3) Subir em desenvolvimento (hot-reload)

O modo dev usa o servidor Flask com recarregamento automÃ¡tico.

docker compose --profile dev up --build


ğŸ“¡ API disponÃ­vel em:
ğŸ‘‰ http://127.0.0.1:8000/

Deixe essa janela rodando.
Em outro terminal, execute os comandos de banco de dados ğŸ‘‡

ğŸ—ï¸ 3.1 Criar tabelas
docker compose --profile dev run --rm api \
  python -m flask --app wsgi.py db-init

ğŸ“¥ 3.2 Importar dados iniciais (matÃ©rias, simulados e questÃµes)

Garanta que os arquivos CSV existam em ./data/:

data/materias.csv
data/simulados.csv
data/enem_questoes.csv


Depois execute:

docker compose --profile dev run --rm api \
  python -m flask --app wsgi.py import-dados


O Docker jÃ¡ mapeia ./data (host) â†’ /seed (container).

ğŸ§ª 3.3 Teste rÃ¡pido (Postman / cURL)
â¤ Listar matÃ©rias
GET http://127.0.0.1:8000/api/v1/materias/

â¤ Criar questÃ£o
POST http://127.0.0.1:8000/api/v1/questoes/
Content-Type: application/json


Body:

{
  "tx_questao": "Capital do Brasil?",
  "ano_questao": 2025,
  "cod_materia": 4,
  "tx_resposta_correta": "D",
  "alternativas": [
    {"tx_letra": "A", "tx_texto": "SÃ£o Paulo"},
    {"tx_letra": "B", "tx_texto": "Rio de Janeiro"},
    {"tx_letra": "C", "tx_texto": "Curitiba"},
    {"tx_letra": "D", "tx_texto": "BrasÃ­lia"},
    {"tx_letra": "E", "tx_texto": "Salvador"}
  ]
}

â¤ Criar simulado
POST http://127.0.0.1:8000/api/v1/simulados/

{
  "titulo": "Simulado ENEM 2025 - MatemÃ¡tica",
  "descricao": "QuestÃµes focadas em MatemÃ¡tica e LÃ³gica",
  "ativo": true
}

â¤ Adicionar questÃ£o a um simulado
POST http://127.0.0.1:8000/api/v1/simulados/1/questoes

{
  "cod_questao": 1,
  "ordem": 1
}

â¤ Registrar resultado do aluno
POST http://127.0.0.1:8000/api/v1/simulados/1/resultados

{
  "cod_usuario": 1,
  "qtd_acertos": 8,
  "qtd_erros": 2
}

ğŸ§© 3.4 Logs / shell dentro do container
docker compose --profile dev logs -f api
docker compose --profile dev exec api bash

ğŸ§¹ 4) Parar / Limpar

Parar serviÃ§os dev:

docker compose --profile dev down


Apagar volume do banco (reset total):

docker compose --profile dev down -v
# ou
docker volume rm vestibulando_db_data

ğŸš€ 5) Subir em produÃ§Ã£o (local) â€“ Gunicorn

O modo prod usa Gunicorn, semelhante ao ambiente de deploy real.

docker compose --profile prod up --build -d
# API: http://127.0.0.1:8000/


Ver logs:

docker compose --profile prod logs -f


Parar:

docker compose --profile prod down


Criar tabelas e importar dados no modo prod:

docker compose --profile prod run --rm api-prod \
  python -m flask --app wsgi.py db-init

docker compose --profile prod run --rm api-prod \
  python -m flask --app wsgi.py import-dados

ğŸ’» 6) Fluxo de desenvolvimento (dia a dia)
docker compose --profile dev up --build


Edite o cÃ³digo dentro de app/; o hot-reload aplica automaticamente.
Teste no Postman / Insomnia / cURL.
Use docker compose logs para acompanhar o backend em tempo real.

ğŸ§© 7) Adicionar / atualizar dependÃªncias

Edite requirements.txt e reconstrua:

docker compose --profile dev build --no-cache api
docker compose --profile dev up


ğŸ’¡ Evite pip install direto no container â€” use rebuild para manter consistÃªncia.

ğŸ—ƒï¸ 8) MigraÃ§Ãµes de banco (opcional, recomendado)

Para evoluir os modelos sem perder dados, use Flask-Migrate (Alembic).

Adicione no requirements.txt:

Flask-Migrate>=4,<5


No app/__init__.py:

from flask_migrate import Migrate
Migrate(app, db)


Comandos:

docker compose --profile dev run --rm api python -m flask --app wsgi.py db init
docker compose --profile dev run --rm api python -m flask --app wsgi.py db migrate -m "sua alteraÃ§Ã£o"
docker compose --profile dev run --rm api python -m flask --app wsgi.py db upgrade

ğŸŒ 9) CORS / Front-end

O backend jÃ¡ libera CORS para:

http://127.0.0.1:5173
http://localhost:5173


No front, sempre use:

fetch(url, { credentials: "include" })


Em produÃ§Ã£o (HTTPS e domÃ­nios diferentes):

SESSION_COOKIE_SAMESITE=None
SESSION_COOKIE_SECURE=True

ğŸ§­ 10) Problemas comuns (FAQ)

âŒ â€œConnection refusedâ€
â†’ ServiÃ§o nÃ£o estÃ¡ rodando ou porta incorreta.
Use:

docker compose ps
docker compose --profile dev logs -f


âŒ â€œCSV nÃ£o encontradoâ€
â†’ Garanta que os arquivos existam em ./data (no host).
Dentro do container, o caminho Ã© /seed.

âŒ â€œAtualizei requirements e nÃ£o refletiuâ€
â†’ Rebuild da imagem (ver seÃ§Ã£o 7).

âŒ â€œReset completo do bancoâ€

docker compose --profile dev down -v
docker compose --profile dev run --rm api python -m flask --app wsgi.py db-init
docker compose --profile dev run --rm api python -m flask --app wsgi.py import-dados


âŒ â€œPorta em usoâ€
â†’ Edite docker-compose.yml e altere:

ports:
  - "8001:8000"

ğŸ§± 11) Estrutura relevante do projeto
app/
 â”œâ”€â”€ models/         # Modelos ORM (SQLAlchemy)
 â”œâ”€â”€ controllers/    # Camada de controle (HTTP)
 â”œâ”€â”€ services/       # LÃ³gica de negÃ³cio
 â”œâ”€â”€ routes/         # Blueprints / endpoints REST
 â”œâ”€â”€ extensions/     # ConfiguraÃ§Ãµes (db, login, oauth)
 â””â”€â”€ __init__.py     # create_app()

wsgi.py              # Entry point principal
data/                # CSVs (materias, simulados, questoes)


ğŸ“ Banco: SQLite â†’ /data/vestibulando.db
ğŸ“ Seeds: ./data (mapeado como /seed dentro do container)

âœ¨ Pronto!
Seu backend Flask estÃ¡ totalmente containerizado, com hot-reload, importaÃ§Ã£o automÃ¡tica de dados e estrutura modular.
Agora Ã© sÃ³ integrar o front-end e comeÃ§ar os testes dos endpoints.